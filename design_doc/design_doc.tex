\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage[normalem]{ulem}
\usepackage{mdframed}
\usepackage{amsmath}
\usepackage{float}

\setlength{\parindent}{0pt}
\newcommand{\R}{\ensuremath{\mathit{R_{1}}}}

% Creating macros for figures and AST components.
\newcommand{\itm}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\key}[1]{\texttt{#1}}
\newcommand{\lp}[0]{\key{(}}
\newcommand{\rp}[0]{\key{)}}
\newcommand{\lb}[0]{\key{[}}
\newcommand{\rb}[0]{\key{]}}

\makeatletter
\newcommand{\Func}[1]{\lp\key{#1}\checknextarg}
\newcommand{\checknextarg}{\@ifnextchar\bgroup{\gobblenextarg}{\rp}}
\newcommand{\gobblenextarg}[1]{~#1\@ifnextchar\bgroup{\gobblenextarg}{\rp}}
\makeatother

\newcommand{\Atm}[0]{\itm{atom}}
\newcommand{\Exp}[0]{\itm{exp}}
\newcommand{\Def}[0]{\itm{def}}
\newcommand{\Op}[0]{\itm{op}}
\newcommand{\var}[0]{\itm{var}}
\newcommand{\Sub}[2]{\Func{-}{#1}{#2}}
\newcommand{\Add}[2]{\Func{+}{#1}{#2}}
\newcommand{\Mul}[2]{\Func{$\boldsymbol{\cdot}$}{#1}{#2}}

% Redesigning Sections
\newcommand{\usection}[1]{\section{#1}\hrule\hfill}


\title{Code Similarity Detection Tool\\
Design Documentation}
\author{Kevin Cao}

\begin{document}
\maketitle

\tableofcontents

\usection{Introduction}

With the rising popularity of cryptocurrencies, it has become crucial that crypto-transactions are not only trustworthy, but also efficient and reliable. While Bitcoin continues to control a majority of the crypto-market, alternatives like Ethereum have also been growing in popularity.

\hfill

For some of these alternatives, transactions are controlled and automated using ``smart contracts". These smart contracts are computer programs that explicitly detail the rules and regulations to an agreement between two or more parties. Once the terms of the agreement have been met, the contract will self-execute and complete the transaction as agreed upon.

\subsection{Purpose}
For many transactions, the corresponding smart contracts are derived from pre-existing popular and mature contracts. By detecting which parent contracts the newer contracts are derived from, the validation and verification process of the contracts can be expedited.

\hfill

As such, a Code Similarity Detection Tool would serve the purpose of assisting in the process of determining the original source of a new contract.

\subsection{Scope}

This Software Design Document details a basic system that serves as a proof of concept for a Code Similarity Detection Tool. For the sake of simplicity, the tool will compare the similarity between code written in a simplified subset of the lisp-based programming language Racket. The system first translates the source code into an Abstract Syntax Tree (AST), and then converts the AST into De Bruijn notation before running the similarity algorithm. Lisp-based languages are best suited for this type of translation, but other languages can also be similarly converted, although the process is a bit more involved.

\usection{Conversion of Source Code}

\subsection{Programming Language Scope}

As mentioned in the previous section, the tool will act on a simplified subset of the Racket programming language, which will be referred to as \R{}. As such, it is best that this subset is defined explicitly.

\hfill

The most basic component in \R{} is an \Atm{}. Atoms include the basic primitive data values such as integers, booleans, and symbols. It also includes variables and empty lists.

\hfill

However, most programs in \R{} will not simply be made up of atoms \textemdash \R{} is largely comprised of \Exp{}s, or expressions. An expression can be a simple atoms, an if-statement, a let-statement, or a function application. Figure \ref{fig:f1} shows some examples of expressions.

\hfill

Of course, in a functional programming language like \R{}, it is imperative that function definitions are explicated. Functional definitions are in a class of their own, \Def{}s. Definitions detail function construction by first taking a variable name to describe the function, and then variable parameters, which are used in the expression body of the definition. Expressions can use the function name from the definition in functional applications, which are categorized under expressions.

\hfill

Finally, an \R{} program can be described as a list of function definitions followed by an expression statement.

\begin{figure}[H]
  \begin{mdframed}
    \[
    \begin{array}{lcl}
      \Atm &::=& \itm{int} \mid \itm{bool} \mid \itm{sym} \mid \itm{`\lp\rp} \mid \var \\
      \Exp &::=& \Atm \mid \Func{if}{\Exp}{\Exp}{\Exp} \mid \lp\key{let}~\lp\lb\var~\Exp\rb\rp~\Exp\rp \\
           &\mid& \Add{\Exp}{\Exp} \mid \Sub{\Exp}{\Exp} \mid \Mul{\Exp}{\Exp} \mid \Func{-}{\Exp} \\
           &\mid& \Func{cons}{\Exp}{\Exp} \mid \Func{eq?}{\Exp}{\Exp} \mid \Func{and}{\Exp}{\Exp} \mid \Func{or}{\Exp}{\Exp} \mid \Func{not}{\Exp} \\ 
           &\mid& \key{...} \\
      \Def &::=& \lp\key{define}~\lp\var~\var~\key{...}\rp~\Exp\rp \\
      \R &::=& \Def~\key{...}~\Exp
    \end{array}
  \]
  \end{mdframed}
  \caption{The concrete syntax of \R. ``..." signifies a list of the previous token.}
  \label{fig:f1}
\end{figure}

\hfill

Compared to Racket, \R{} is a fairly barebones language\textemdash however, \R{} will be sufficient in demonstrating the core mechanic of the system.

\subsection{Abstract Syntax Trees}
Before we can begin the similarity algorithm, we first need to convert the source code into an Abstract Syntax Tree, which abstracts away the source code into the node objects of the tree. In short, we convert the concrete syntax detailed in Figure \ref{fig:f1} into the abstract syntax detailed in Figure \ref{fig:f2}.

\begin{figure}[H]
  \begin{mdframed}
    \[
    \begin{array}{lcl}
      \Atm &::=& \Func{Int}{\itm{int}} \mid \Func{Bool}{\itm{bool}} \mid \Func{Sym}{\itm{sym}} \mid \Func{Var}{\var} \\
      \Op &::=& \Func{Var}{\var} \mid \key{+} \mid \key{-} \mid \key{$\boldsymbol{\cdot}$} \mid \key{cons} \mid \key{eq?} \mid \key{and} \mid \key{or} \mid \key{not} \mid \key{...} \\
      \Exp &::=& \Atm \mid \Func{If}{\Exp}{\Exp}{\Exp} \mid \Func{Let}{\Func{Var}{\var}}{\Exp}{\Exp} \mid \Func{Apply}{\Op}{\Exp}{...} \\
      \Def &::=& \Func{Def}{\var}{\lp\var{}~...\rp}{\Exp} \\
      \R &::=& \Func{Program}{\lp\Def{}~...\rp}{\Exp}
    \end{array}
  \]
  \end{mdframed}
  \caption{The abstract syntax of \R.}
  \label{fig:f2}
\end{figure}

In Figure \ref{fig:f2}, the components of \R{} are converted into objects. You may also notice there is a new classification\textemdash\Op. Here, we have abstracted away functions to be either custom functions created in the program [\Func{Var}{\var}], or inbuilt functions in the language itself [\key{+}, \key{cons}, etc.]. By doing so, we are able to abstract away all function applications to the \Func{Apply}{\Op}{\Exp}{...}\space object.

\hfill

The rest of the Figure \ref{fig:f2} is fairly self-explanatory, so we will not go into further detail here.
\end{document}
