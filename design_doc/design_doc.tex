\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage[normalem]{ulem}
\usepackage{mdframed}
\usepackage{amsmath}
\usepackage{float}
\usepackage{listings}

\setlength{\parindent}{0pt}
\newcommand{\R}{\ensuremath{\mathit{R_{1}}}}

% Creating macros for figures and AST components.
\newcommand{\itm}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\key}[1]{\texttt{#1}}
\newcommand{\lp}[0]{\key{(}}
\newcommand{\rp}[0]{\key{)}}
\newcommand{\lb}[0]{\key{[}}
\newcommand{\rb}[0]{\key{]}}
\newcommand{\lamb}[0]{\key{$\lambda$}}

\makeatletter
\newcommand{\Func}[1]{\lp\key{#1}\checknextarg}
\newcommand{\checknextarg}{\@ifnextchar\bgroup{\gobblenextarg}{\rp}}
\newcommand{\gobblenextarg}[1]{~#1\@ifnextchar\bgroup{\gobblenextarg}{\rp}}
\makeatother

\newcommand{\Atm}[0]{\itm{atom}}
\newcommand{\Exp}[0]{\itm{exp}}
\newcommand{\Def}[0]{\itm{def}}
\newcommand{\Op}[0]{\itm{op}}
\newcommand{\var}[0]{\itm{var}}
\newcommand{\Sub}[2]{\Func{-}{#1}{#2}}
\newcommand{\Add}[2]{\Func{+}{#1}{#2}}
\newcommand{\Mul}[2]{\Func{$\boldsymbol{\cdot}$}{#1}{#2}}

% Redesigning Sections
\newcommand{\usection}[1]{\section{#1}\hrule\hfill}


\title{Code Similarity Detection Tool\\
Design Documentation}
\author{Kevin Cao}

\begin{document}
\maketitle

\tableofcontents

\usection{Introduction}

With the rising popularity of cryptocurrencies, it has become crucial that crypto-transactions are not only trustworthy, but also efficient and reliable. While Bitcoin continues to control a majority of the crypto-market, alternatives like Ethereum have also been growing in popularity.

\hfill

For some of these alternatives, transactions are controlled and automated using ``smart contracts". These smart contracts are computer programs that explicitly detail the rules and regulations to an agreement between two or more parties. Once the terms of the agreement have been met, the contract will self-execute and complete the transaction as agreed upon.

\subsection{Purpose}
For many transactions, the corresponding smart contracts are derived from pre-existing popular and mature contracts. By detecting which parent contracts the newer contracts are derived from, the validation and verification process of the contracts can be expedited.

\hfill

As such, a Code Similarity Detection Tool would serve the purpose of assisting in the process of determining the original source of a new contract.

\subsection{Scope}

This Software Design Document details a basic system that serves as a proof of concept for a Code Similarity Detection Tool. For the sake of simplicity, the tool will compare the similarity between code written in a simplified subset of the lisp-based programming language Racket. The system first translates the source code into an Abstract Syntax Tree (AST), and then converts the AST into a variation of De Bruijn notation before running the similarity algorithm. Lisp-based languages are best suited for this type of translation, but other languages can also be similarly converted, although the process is a bit more involved.

\hfill

Furthermore, it should be clarified that the Code Similarity Detection Tool detailed in this document evaluates syntactical similarity, \emph{not semantic similarity}. The reasoning behind this is detailed later.

\usection{Conversion of Source Code}

\subsection{Programming Language Scope}

As mentioned in the previous section, the tool will act on a simplified subset of the Racket programming language, which will be referred to as \R{}. As such, it is best that this subset is defined explicitly.

\hfill

The most basic component in \R{} is an \Atm{}. Atoms include the basic primitive data values such as integers, booleans, and symbols. It also includes variables and empty lists. Furthermore, as functions are first-class citizens in \R{}, inbuilt functions can also be considered as atoms.

\hfill

However, most programs in \R{} will not simply be made up of atoms \textemdash \R{} is largely comprised of \Exp{}s, or expressions. An expression can be a simple atoms, an if-statement, a let-statement, a function application, or a lambda function. Figure \ref{fig:f1} shows some examples of expressions.

\hfill

Of course, in a functional programming language like \R{}, it is imperative that function definitions are explicated. Functional definitions are in a class of their own, \Def{}s. Definitions detail function construction by first taking a variable name to describe the function, and then variable parameters, which are used in the expression body of the definition. Expressions can use the function name from the definition in functional applications, which are categorized under expressions.

\hfill

Finally, an \R{} program can be described as a list of function definitions followed by an expression statement.

\begin{figure}[H]
  \begin{mdframed}
    \[
    \begin{array}{lcl}
      \Atm &::=& \itm{int} \mid \itm{bool} \mid \itm{sym} \mid \itm{`\lp\rp} \mid \var \mid \key{+} \mid \key{-} \mid \key{$\boldsymbol{\cdot}$} \mid \key{cons} \mid \key{eq?} \mid \key{and} \mid \key{or} \mid \key{not} \mid \key{...} \\
      \Exp &::=& \Atm \mid \Func{if}{\Exp}{\Exp}{\Exp} \mid \lp\key{let}~\lp\lb\var~\Exp\rb\rp~\Exp\rp \\
           &\mid& \Add{\Exp}{\Exp} \mid \Sub{\Exp}{\Exp} \mid \Mul{\Exp}{\Exp} \mid \Func{-}{\Exp} \\
           &\mid& \Func{cons}{\Exp}{\Exp} \mid \Func{eq?}{\Exp}{\Exp} \mid \Func{and}{\Exp}{\Exp} \mid \Func{or}{\Exp}{\Exp} \mid \Func{not}{\Exp} \\ 
           &\mid& \Func{\lamb}{\var}{...}{\Exp} \mid \key{...} \\
      \Def &::=& \lp\key{define}~\lp\var~\var~\key{...}\rp~\Exp\rp \\
      \R &::=& \Def~\key{...}~\Exp
    \end{array}
  \]
  \end{mdframed}
  \caption{The concrete syntax of \R. ``..." signifies a list of the previous token.}
  \label{fig:f1}
\end{figure}

Compared to Racket, \R{} is a fairly barebones language\textemdash however, \R{} will be sufficient in demonstrating the core mechanic of the system.

\subsection{Abstract Syntax Trees}
Before we can begin the similarity algorithm, we first need to convert the source code into an Abstract Syntax Tree, which abstracts away the source code into the node objects of the tree. In short, we convert the concrete syntax detailed in Figure \ref{fig:f1} into the abstract syntax detailed in Figure \ref{fig:f2}.

\begin{figure}[H]
  \begin{mdframed}
    \[
    \begin{array}{lcl}
      \Op &::=& \key{+} \mid \key{-} \mid \key{$\boldsymbol{\cdot}$} \mid \key{cons} \mid \key{eq?} \mid \key{and} \mid \key{or} \mid \key{not} \mid \key{...} \\
      \Atm &::=& \Func{Int}{\itm{int}} \mid \Func{Bool}{\itm{bool}} \mid \Func{Sym}{\itm{sym}} \mid \Func{Var}{\var} \mid \Func{Op}{\Op} \\
      \Exp &::=& \Atm \mid \Func{If}{\Exp}{\Exp}{\Exp} \mid \Func{Let}{\Func{Var}{\var}}{\Exp}{\Exp} \mid \Func{Apply}{\Exp}{\Exp}{...} \\
           &\mid& \Func{Lambda}{\lp\Func{Var}{\var}{}~...\rp}{\Exp} \mid \key{...} \\
      \Def &::=& \Func{Def}{\Func{Var}{\var}}{\lp\Func{Var}{\var}{}~...\rp}{\Exp} \\
      \R &::=& \Func{Program}{\lp\Def{}~...\rp}{\Exp}
    \end{array}
  \]
  \end{mdframed}
  \caption{The abstract syntax of \R.}
  \label{fig:f2}
\end{figure}

In Figure \ref{fig:f2}, the components of \R{} are converted into objects. You may notice a new classification, \Op{}. This simply acts as an abstraction for inbuilt functions in the \R{} language so that we can create the \Func{Op}{\Op}\space object in \Atm.

\hfill

The rest of the Figure \ref{fig:f2} is fairly self-explanatory, so we will not go into further detail here.

\subsection{De Bruijn Notation}

While certain structures of code, such as if-statements or function definitions, must follow a set syntax, variable names are up to the discretion of the developer. In order to properly perform the code similarity algorithm, we must ignore the variable names and normalize the syntax.

\hfill

One method of doing so is to use De Bruijn indices\textemdash variables are instead replaced with numbers that indicate how many variable bindings exist between the variable occurrence and its corresponding binding. To avoid confusion with actual integers, we will rename variables as \texttt{v\#}.

\begin{figure}[H]
  \begin{mdframed}
    \begin{lstlisting}[escapechar=\%]
; Original Syntax
(%\lamb% (x)
  (%\lamb% (y)
    (%\lamb% (z)
      (+ x (+ y z)))))

; De Bruijnized Syntax
(%\lamb%
  (%\lamb% 
    (%\lamb% 
      (+ v2 (+ v1 v0)))))
    \end{lstlisting}
  \end{mdframed}
  \caption{Demonstrating conversion to De Bruijn indices.}
  \label{fig:f3}
\end{figure}

However, this solution is not perfect\textemdash multi-variable functions would require currying in order to properly be De Bruijnized. Unfortunately, currying functions would make it difficult to perform similarity checks on function applications. In a later section, we will discuss the methodology for comparing two separate functional applications, but in short, we will need to collect all function arguments to properly compare. If functions are curried, then collecting the function arguments will require traversing down the AST and determining which expressions belong to the function application, which is messier than would be preferred (shown in Figure \ref{fig:f4}).

\hfill

\begin{figure}[H]
  \begin{mdframed}
    \begin{lstlisting}[escapechar=\%]
; Original Syntax
(define (func x y z)
  (+ x (+ y z)))

; Curried Syntax
(define (func x)
  (%\lamb% (y)
    (%\lamb% (z)
      (+ x (+ y z)))))

; Curried Function Application 1
(((func (+ 4 1)) (+ 2 3)) 6)

; Curried Function Application 2
(((func 6) (+ 4 1)) (+ 2 3))

; AST 1
(Apply
  (Apply
    (Apply
      (Var func) (Apply (Op +) (Int 4) (Int 1)))
    (Apply (Op +) (Int 2) (Int 3)))
  (Int 6))

; AST 2
(Apply
  (Apply
    (Apply
      (Var func) (Int 6))
    (Apply (Op +) (Int 4) (Int 1)))
  (Apply (Op +) (Int 2) (Int 3)))
    \end{lstlisting}
  \end{mdframed}
  \caption{The AST representation of two similar applications of \key{func} hide away the arguments of \key{func}, making it difficult to parse out the arguments for comparison.}
  \label{fig:f4}
\end{figure}

It would be best to keep functions as is so that all of the arguments are kept within the same \key{Apply} object at the same level. As such, we use a variation of De Bruijn notation such that for multi-variable functions, variables are considered bound in the order in which they appear in the list of parameters. In essence, we simulate the effect of currying without actually expanding the function and currying it (See Figure \ref{fig:f5}).

\begin{figure}[H]
  \begin{mdframed}
    \begin{lstlisting}[escapechar=\%]
; Original Syntax
(define (func x y z)
  (+ x (+ y z)))

; De Bruijn Variation Notation
(define (func)
  (+ v2 v1 v0))
    \end{lstlisting}
  \end{mdframed}
  \caption{Example of De Bruijn Variation Notation}
  \label{fig:f5}
\end{figure}

Fortunately, as the ultimate purpose of this notation is to check syntactical similarities, the notation's tendency to obscure the semantical meaning of variables is not a weakness we must consider too much.
\end{document}
