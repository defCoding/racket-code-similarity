\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage[normalem]{ulem}
\usepackage{mdframed}
\usepackage{amsmath}
\usepackage{float}
\usepackage{listings}

\setlength{\parindent}{0pt}
\newcommand{\R}{\ensuremath{\mathit{R_{1}}}}
\newcommand{\tab}{\hspace{6mm}}

% Creating macros for figures and AST components.
\newcommand{\itm}[1]{\ensuremath{\mathit{#1}}}
\newcommand{\key}[1]{\texttt{#1}}
\newcommand{\lp}[0]{\key{(}}
\newcommand{\rp}[0]{\key{)}}
\newcommand{\lb}[0]{\key{[}}
\newcommand{\rb}[0]{\key{]}}
\newcommand{\lamb}[0]{\key{$\lambda$}}

\makeatletter
\newcommand{\Func}[1]{\lp\key{#1}\checknextarg}
\newcommand{\checknextarg}{\@ifnextchar\bgroup{\gobblenextarg}{\rp}}
\newcommand{\gobblenextarg}[1]{~#1\@ifnextchar\bgroup{\gobblenextarg}{\rp}}
\makeatother

\newcommand{\Atm}[0]{\itm{atom}}
\newcommand{\Exp}[0]{\itm{exp}}
\newcommand{\Def}[0]{\itm{def}}
\newcommand{\Op}[0]{\itm{op}}
\newcommand{\var}[0]{\itm{var}}
\newcommand{\Sub}[2]{\Func{-}{#1}{#2}}
\newcommand{\Add}[2]{\Func{+}{#1}{#2}}
\newcommand{\Mul}[2]{\Func{$\boldsymbol{\cdot}$}{#1}{#2}}

% Redesigning Sections
\newcommand{\usection}[1]{\section{#1}\hrule\hfill}


\title{Code Similarity Detection Tool\\
Design Documentation}
\author{Kevin Cao}

\begin{document}
\maketitle

\tableofcontents

\usection{Introduction}

With the rising popularity of cryptocurrencies, it has become crucial that crypto-transactions are not only trustworthy, but also efficient and reliable. While Bitcoin continues to control a majority of the crypto-market, alternatives like Ethereum have also been growing in popularity.

\hfill

For some of these alternatives, transactions are controlled and automated using ``smart contracts". These smart contracts are computer programs that explicitly detail the rules and regulations to an agreement between two or more parties. Once the terms of the agreement have been met, the contract will self-execute and complete the transaction as agreed upon.

\subsection{Purpose}
For many transactions, the corresponding smart contracts are derived from pre-existing popular and mature contracts. By detecting which parent contracts the newer contracts are derived from, the validation and verification process of the contracts can be expedited.

\hfill

As such, a Code Similarity Detection Tool would serve the purpose of assisting in the process of determining the original source of a new contract.

\subsection{Scope}

This Software Design Document details a basic system that serves as a proof of concept for a Code Similarity Detection Tool. For the sake of simplicity, the tool will compare the similarity between code written in a simplified subset of the lisp-based programming language Racket. The system first translates the source code into an Abstract Syntax Tree (AST), and then converts the AST into a variation of De Bruijn notation before running the similarity algorithm. Lisp-based languages are best suited for this type of translation, but other languages can also be similarly converted, although the process is a bit more involved.

\hfill

Furthermore, it should be clarified that the Code Similarity Detection Tool detailed in this document evaluates syntactical similarity, \emph{not semantic similarity}. The reasoning behind this is detailed later.

\usection{Conversion of Source Code}

\subsection{Programming Language Scope}

As mentioned in the previous section, the tool will act on a simplified subset of the Racket programming language, which will be referred to as \R{}. As such, it is best that this subset is defined explicitly.

\hfill

The most basic component in \R{} is an \Atm{}. Atoms include the basic primitive data values such as integers, booleans, and strings. It also includes variables and empty lists. Furthermore, as functions are first-class citizens in \R{}, inbuilt functions can also be considered as atoms.

\hfill

However, most programs in \R{} will not simply be made up of atoms \textemdash \R{} is largely comprised of \Exp{}s, or expressions. An expression can be a simple atoms, an if-statement, a let-statement, a function application, or a lambda function. Figure \ref{concrete-syntax} shows some examples of expressions.

\hfill

Of course, in a functional programming language like \R{}, it is imperative that function definitions are explicated. Functional definitions are in a class of their own, \Def{}s. Definitions detail function construction by first taking a variable name to describe the function, and then variable parameters, which are used in the expression body of the definition. Expressions can use the function name from the definition in functional applications, which are categorized under expressions.

\hfill

Finally, an \R{} program can be described as a list of function definitions followed by a list of expression statements.

\begin{figure}[H]
  \begin{mdframed}
    \[
    \begin{array}{lcl}
      \Atm &::=& \itm{int} \mid \itm{bool} \mid \itm{str} \mid \itm{empty} \mid \var \mid \key{+} \mid \key{-} \mid \key{$\boldsymbol{\cdot}$} \mid \key{cons} \mid \key{eq?} \mid \key{and} \mid \key{or} \mid \key{not} \mid ... \\
      \Exp &::=& \Atm \mid \Func{if}{\Exp}{\Exp}{\Exp} \mid \lp\key{let}~\lp\lb\var~\Exp\rb\rp~\Exp\rp \\
           &\mid& \Add{\Exp}{\Exp} \mid \Sub{\Exp}{\Exp} \mid \Mul{\Exp}{\Exp} \mid \Func{-}{\Exp} \\
           &\mid& \Func{cons}{\Exp}{\Exp} \mid \Func{eq?}{\Exp}{\Exp} \mid \Func{and}{\Exp}{\Exp} \mid \Func{or}{\Exp}{\Exp} \mid \Func{not}{\Exp} \\ 
           &\mid& \Func{\lamb}{\lp\var}{...\rp}{\Exp} \mid ... \\
      \Def &::=& \lp\key{define}~\lp\var~\var~...\rp~\Exp\rp \\
      \R &::=& \Def~...~\Exp~...
    \end{array}
  \]
  \end{mdframed}
  \caption{The concrete syntax of \R. ``..." signifies a list of the previous token.}
  \label{concrete-syntax}
\end{figure}

Compared to Racket, \R{} is a fairly barebones language\textemdash however, \R{} will be sufficient in demonstrating the core mechanic of the system.

\subsection{Abstract Syntax Trees}
Before we can begin the similarity algorithm, we first need to convert the source code into an Abstract Syntax Tree, which abstracts away the source code into the node objects of the tree. In short, we convert the concrete syntax detailed in Figure \ref{concrete-syntax} into the abstract syntax detailed in Figure \ref{abstract-syntax}.

\begin{figure}[H]
  \begin{mdframed}
    \[
    \begin{array}{lcl}
      \Op &::=& \key{+} \mid \key{-} \mid \key{$\boldsymbol{\cdot}$} \mid \key{cons} \mid \key{eq?} \mid \key{and} \mid \key{or} \mid \key{not} \mid ... \\
      \Atm &::=& \Func{Int}{\itm{int}} \mid \Func{Bool}{\itm{bool}} \mid \Func{Str}{\itm{str}} \mid \Func{Empty} \mid \Func{Var}{\var} \mid \Func{Op}{\Op} \\
      \Exp &::=& \Atm \mid \Func{If}{\Exp}{\Exp}{\Exp} \mid \Func{Let}{\Func{Var}{\var}}{\Exp}{\Exp} \mid \Func{Apply}{\Exp}{\Exp}{...} \\
           &\mid& \Func{Lambda}{\lp\Func{Var}{\var}{}~...\rp}{\Exp} \mid ... \\
      \Def &::=& \Func{Def}{\Func{Var}{\var}}{\lp\Func{Var}{\var}{}~...\rp}{\Exp} \\
      \R &::=& \Func{Program}{\lp\Def{}~...\rp}{\lp\Exp{}...\rp}
    \end{array}
  \]
  \end{mdframed}
  \caption{The abstract syntax of \R.}
  \label{abstract-syntax}
\end{figure}

In Figure \ref{abstract-syntax}, the components of \R{} are converted into objects. You may notice a new classification, \Op{}. This simply acts as an abstraction for inbuilt functions in the \R{} language so that we can create the \Func{Op}{\Op}\space object in \Atm.

\hfill

The rest of the Figure \ref{abstract-syntax} is fairly self-explanatory, so we will not go into further detail here.

\subsection{De Bruijn Notation}

While certain structures of code, such as if-statements or function definitions, must follow a set syntax, variable names are up to the discretion of the developer. In order to properly perform the code similarity algorithm, we must ignore the variable names and standardize the syntax.

\hfill

One method of doing so is to use De Bruijn indices\textemdash variables are instead replaced with numbers that indicate how many variable bindings exist between the variable occurrence and its corresponding binding. To avoid confusion with actual integers, we will rename variables as \texttt{v\#}.

\begin{figure}[H]
  \begin{mdframed}
    \begin{lstlisting}[escapechar=\%]
; Original Syntax
(%\lamb% (x)
  (%\lamb% (y)
    (%\lamb% (z)
      (+ x (+ y z)))))

; De Bruijnized Syntax
(%\lamb%
  (%\lamb% 
    (%\lamb% 
      (+ v2 (+ v1 v0)))))
    \end{lstlisting}
  \end{mdframed}
  \caption{Demonstrating conversion to De Bruijn indices.}
  \label{debruijn}
\end{figure}

However, this solution is not perfect\textemdash multi-variable functions would require currying in order to properly be De Bruijnized. Unfortunately, currying functions would make it difficult to perform similarity checks on function applications. In a later section, we will discuss the methodology for comparing two separate functional applications, but in short, we will need to collect all function arguments to properly compare. If functions are curried, then collecting the function arguments will require traversing down the AST and determining which expressions belong to the function application, which is messier than would be preferred (shown in Figure \ref{curried-ast}).

\hfill

\begin{figure}[H]
  \begin{mdframed}
    \begin{lstlisting}[escapechar=\%]
; Original Syntax
(define (func x y z)
  (+ x (+ y z)))

; Curried Syntax
(define (func x)
  (%\lamb% (y)
    (%\lamb% (z)
      (+ x (+ y z)))))

; Curried Function Application 1
(((func (+ 4 1)) (+ 2 3)) 6)

; Curried Function Application 2
(((func 6) (+ 4 1)) (+ 2 3))

; AST 1
(Apply
  (Apply
    (Apply
      (Var func) (Apply (Op +) (Int 4) (Int 1)))
    (Apply (Op +) (Int 2) (Int 3)))
  (Int 6))

; AST 2
(Apply
  (Apply
    (Apply
      (Var func) (Int 6))
    (Apply (Op +) (Int 4) (Int 1)))
  (Apply (Op +) (Int 2) (Int 3)))
    \end{lstlisting}
  \end{mdframed}
  \caption{The AST representation of two similar applications of \key{func} hide away the arguments of \key{func}, making it difficult to parse out the arguments for comparison.}
  \label{curried-ast}
\end{figure}

It would be best to keep functions as is so that all of the arguments are kept within the same \key{Apply} object at the same level. As such, we use a variation of De Bruijn notation such that for multi-variable functions, variables are considered bound in the order in which they appear in the list of parameters. In essence, we simulate the effect of currying without actually expanding the function and currying it (See Figure \ref{debruijn-variation}).

\begin{figure}[H]
  \begin{mdframed}
    \begin{lstlisting}[escapechar=\%]
; Original Syntax
(define (func x y z)
  (+ x (+ y z)))

; De Bruijn Variation Notation
(define (func)
  (+ v2 v1 v0))
    \end{lstlisting}
  \end{mdframed}
  \caption{Example of De Bruijn Variation Notation}
  \label{debruijn-variation}
\end{figure}

\subsection{Implementation}
\subsubsection{AST Conversion}
Fortunately, the Racket programming language does make parsing \R{} rather simple as its \key{read} function will read individual expressions from the file. Racket's \key{match} function allows for recursive pattern matching, so a parser function can be applied recursively on the sub-expressions within expressions.

\hfill

To facilitate in the process of converting the concrete syntax of the \R{} language into an AST, we can take advantage of Racket \key{structs}, lending to a somewhat OOP-style implementation (See Table \ref{ast-structs}). As each expression is parsed, we generate the corresponding \key{struct}, and recurse on its components.

\begin{table}[H]
  \centering
  \begin{mdframed}
    \begin{tabular}{ll}
      \key{If} & \key{Int} \\
      \tab con : condition & \tab n : integer value \\
      \tab consq : consequent & \key{Bool} \\
      \tab alter : alternative & \tab b : boolean value \\
      \key{Let} & \key{Str} \\
      \tab v : variable name & \tab s : string \\
      \tab val : value to bind & \key{Op} \\
      \tab body : main body of let & \tab o : operation \\
      \key{Lambda} & \key{Var} \\
      \tab p-ls : list of parameters & \tab v : variable name \\
      \tab body : main body of lambda & \key{Empty} \\
      \key{Def} \\
      \tab fn-name : function name \\
      \tab p-ls : list of parameters \\
      \tab body : main body of function \\
      \key{Program} \\
      \tab def-ls : list of definitions \\
      \tab exp-ls : list of expressions
    \end{tabular}
  \end{mdframed}
  \caption{\key{struct} Representations of AST Nodes}
  \label{ast-structs}
\end{table}

After repeatedly calling the \key{read} function on the input file and parsing it, we are left with a list of various expression/definition AST nodes. With a quick partition of the list, we can then construct the \key{Program} struct with the disjoint list of definitions and expressions.

\subsubsection{De Bruijn Conversion}
Once we have finished the conversion from concrete syntax to an AST, converting to De Bruijn notation is quite simple, especially since we are not evaluating the program's behavior, only changing the syntax form.

\hfill

To calculate the number of bindings between a variable's occurrence and its initial binding, we maintain an environment of variables as we evaluate an expression. For this use case, the environment is quite simple\textemdash it is simply a list of variables, and each time we encounter a variable binding, we add the variable to the front of the list. When we see an occurrence of a variable, we look for its index in the environment, and that will be the \key{\#} in our \key{v\#}.

\hfill

If the variable does not exist in the environment, we assume that the variable is a function that has already been defined in the source code, and leave it as is. As we are simply checking the syntax of the source code and are not checking for errors, we assume that there are no occurrences of free (unbound) variables.

\hfill

There was some consideration made toward the neccessity of standardizing function names as well, perhaps relabeling functions in the form \key{f\#}, so that there could be a differentiation made between functions and variables. However, it was ultimately decided that doing so would not have a large effect on the similarity algorithm.

\section{The Similarity Algorithm}

Up until this point, the program has been implemented in the Racket programming language. The algorithm is best implemented in an object oriented programming language, so at this point, we make a transition from Racket to Python.

\subsection{Comparing ASTs}

\end{document}
